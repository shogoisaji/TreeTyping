let database = {
    algorithm: "計算法",
    array: "配列",
    boolean: "真偽値",
    cache: "キャッシュデータ",
    callback: "後から呼び出す処理",
    class: "分類",
    client: "依頼者",
    compile: "組み立てる",
    constant: "不変の値",
    constructor: "構築方法",
    database: "データの集合",
    debug: "誤り探し",
    default: "初期値",
    delegate: "他人に任せる",
    element: "成分",
    encrypt: "暗号化する",
    exception: "予想外の事象",
    function: "機能",
    generic: "全般的な",
    inherit: "受け継ぐ",
    instance: "実例",
    interface: "接続面",
    iterator: "反復処理",
    keyword: "重要な単語",
    library: "資料集",
    literal: "直訳",
    metadata: "データのデータ",
    method: "方法",
    module: "部品",
    namespace: "名前の範囲",
    native: "元来の",
    null: "無し",
    object: "目的",
    operator: "操作者",
    override: "上書き",
    parameter: "変数",
    pointer: "指し示すもの",
    private: "非公開の",
    property: "特性",
    public: "公開の",
    query: "問い合わせ",
    recursion: "自己参照",
    reference: "参照",
    return: "返却",
    scope: "範囲",
    server: "提供者",
    singleton: "唯一の存在",
    stack: "積み重ね",
    static: "静的な",
    string: "文字列",
    syntax: "文法",
    thread: "続き",
    token: "記号",
    void: "無効",
    while: "間",
    abstract: "抽象的な",
    assert: "主張する",
    binary: "二進法の",
    byte: "バイト",
    case: "事例",
    catch: "捕捉",
    char: "文字",
    conditional: "条件付きの",
    continue: "続ける",
    decimal: "十進法の",
    define: "定義",
    delete: "削除する",
    double: "二倍の",
    dynamic: "動的な",
    else: "それ以外の場合",
    enum: "列挙型",
    event: "事象",
    explicit: "明確にする",
    extends: "拡張する",
    final: "最終的な",
    finally: "最後に",
    float: "浮動小数点数",
    for: "ため",
    goto: "行き先",
    implicit: "暗黙の",
    import: "取り込む",
    inline: "一列に",
    long: "長い",
    package: "束ねる",
    private: "非公開の",
    protected: "保護された",
    public: "公開の",
    short: "短い",
    signed: "符号付きの",
    sizeof: "大きさ",
    switch: "切り替える",
    this: "これ",
    throw: "投げる",
    try: "試す",
    typedef: "型定義",
    unsigned: "符号なしの",
    virtual: "仮想的な",
    volatile: "揮発性の",
    loop: "反復",
    arraylist: "配列リスト",
    vector: "向き",
    queue: "列",
    stack: "積み重ね",
    map: "対応付ける",
    set: "集合",
    graph: "図形",
    tree: "木構造",
    node: "節",
    edge: "辺",
    vertex: "頂点",
    weight: "重み",
    hash: "ハッシュ",
    dictionary: "辞書",
    element: "要素",
    tag: "マーカー",
    attribute: "属性",
    text: "文字列",
    nest: "巣穴",
    root: "根本",
    branch: "分岐",
    leaf: "葉",
    child: "子供",
    parent: "親",
    ancestor: "先祖",
    descendant: "子孫",
    sibling: "兄弟",
    index: "索引",
    value: "値",
    data: "データ",
    information: "情報",
    knowledge: "知識",
    wisdom: "知恵",
    truth: "真実",
    lie: "偽り",
    fact: "事実",
    hypothesis: "仮説",
    theory: "理論",
    principle: "原則",
    law: "法律",
    formula: "公式",
    solution: "解",
    problem: "問題",
    difficulty: "困難",
    easy: "易しい",
    hard: "困難",
    simple: "単純",
    complex: "複雑",
    chaos: "混乱",
    order: "秩序",
    random: "無作為",
    deterministic: "決定的",
    finite: "有限",
    infinite: "無限",
    tiny: "小さい",
    huge: "大きい",
    fast: "速い",
    slow: "遅い",
    up: "上",
    down: "下",
    left: "左",
    right: "右",
    start: "始め",
    end: "終わり",
    past: "過去",
    present: "現在",
    future: "未来",
    variable: "変数",
    sequence: "順序",
    execute: "実行",
    pattern: "パターン",
    boolean: "ブーリアン",
    resolve: "解決する",
    runtime: "実行時間",
    timeout: "タイムアウト",
    loopback: "ループバック",
    hardware: "ハードウェア",
    software: "ソフトウェア",
    firewall: "ファイアウォール",
    protocol: "プロトコル",
    intranet: "イントラネット",
    internet: "インターネット",
    hostname: "ホスト名",
    database: "データベース",
    username: "ユーザー名",
    password: "パスワード",
    timestamp: "タイムスタンプ",
    path: "パス",
    resource: "リソース",
    memory: "メモリ",
    process: "プロセス",
    thread: "スレッド",
    argument: "引数",
    compile: "コンパイル",
    linker: "リンカー",
    debugger: "デバッガ",
    binary: "バイナリ",
    cluster: "クラスタ",
    packet: "パケット",
    payload: "ペイロード",
    encryption: "暗号化",
    compression: "圧縮",
    algorithm: "アルゴリズム",
    heuristic: "ヒューリスティック",
    iteration: "反復",
    recursion: "再帰",
    polymorphism: "ポリモーフィズム",
    abstraction: "抽象化",
    encapsulation: "カプセル化",
    inheritance: "継承",
    composition: "合成",
    delegation: "委譲",
    event: "イベント",
    handler: "ハンドラ",
    trigger: "トリガー",
    listener: "リスナー",
    directive: "ディレクティブ",
    schema: "スキーマ",
    query: "クエリ",
    mutation: "変異",
    resolver: "リゾルバ",
    graphql: "グラフキューエル",
    restapi: "レストエーアイ",
    websocket: "ウェブソケット",
    frontend: "フロントエンド",
    backend: "バックエンド",
    middleware: "ミドルウェア",
    framework: "フレームワーク",
    library: "ライブラリ",
    dependency: "依存関係",
    version: "バージョン",
    deprecated: "非推奨",
    console: "コンソール",
    terminal: "ターミナル",
    emulator: "エミュレータ",
    syscall: "システムコール",
    interrupt: "割り込み",
    register: "レジスタ",
    buffer: "バッファ",
    cache: "キャッシュ",
    latency: "レイテンシ",
    bandwidth: "帯域幅",
    throughput: "スループット",
    deadlock: "デッドロック",
    racecond: "レースコンディション",
    atomicity: "アトミシティ",
    isolation: "分離",
    durable: "永続性",
    consistent: "一貫性",
    primary: "プライマリ",
    secondary: "セカンダリ",
    replicate: "レプリケート",
    partition: "パーティション",
    schemaless: "スキーマレス",
    document: "ドキュメント",
    structure: "構造",
    unstructured: "非構造化",
    graphdb: "グラフDB",
    analytics: "分析",
    warehouse: "ウェアハウス",
    pipeline: "パイプライン",
    etl: "ETL",
    batch: "バッチ",
    realtime: "リアルタイム",
    timestamp: "タイムスタンプ",
    datetime: "日時",
    epoch: "エポック",
    timezone: "タイムゾーン",
    interval: "間隔",
    duration: "期間",
    mapping: "マッピング",
    projection: "投影",
    transform: "変換",
    filtering: "フィルタリング",
    sorting: "ソート",
    merging: "マージ",
    reduction: "還元",
    accumulation: "蓄積",
    aggregate: "集計",
    groupby: "グループ化",
};

let currentWord = "";
let currentIndex = 0;
let startTime = 0.0;
let errors = 0;
let timerInterval;
let totalLength = 0;
let totalWords = 0;
let maxWords = 0;
let typeSelect = 1;
let setLevel = 1;
let levels = {
    1: 10,
    2: 50,
    3: 100,
};
let Types = {
    1: "Word",
    2: "Random",
};

window.onload = function () {
    let urlParams = new URLSearchParams(window.location.search);
    for (let key in levels) {
        if (levels[key] == urlParams.get("words")) {
            setLevel = key;
        }
    }
    for (let key in Types) {
        if (Types[key] == urlParams.get("type")) {
            typeSelect = key;
        }
    }
    chengeType(typeSelect);
    startGame(setLevel);
    document.querySelector('label[for="level1"]').textContent = levels[1];
    document.querySelector('label[for="level2"]').textContent = levels[2];
    document.querySelector('label[for="level3"]').textContent = levels[3];
};

function chengeType(type) {
    typeSelect = Types[type];
    startGame();
}

function chengeLevel(level) {
    setLevel = level;
    startGame();
}

function startGame() {
    totalLength = 0;
    document.querySelectorAll('input[type="radio"]').forEach((elem) => {
        elem.checked = false;
    });

    document.querySelectorAll('input[type="radio"] + label').forEach((elem) => {
        elem.style.color = "#959595";
    });
    document.getElementById(`level${setLevel}`).checked = true;
    document.querySelector(`#level${setLevel} + label`).style.color = "orange";
    document.getElementById(typeSelect).checked = true;
    document.querySelector(`#${typeSelect} + label`).style.color = "orange";

    currentIndex = 0;
    errors = 0;
    clearInterval(timerInterval);
    startTime = 0.0;
    maxWords = levels[setLevel];
    if (typeSelect == "Word") {
        newWord();
    } else if (typeSelect == "Random") {
        newWordRandom();
    }
    document.getElementById("timer").innerText = "0.0";
    document.getElementById("progressBar").style.width = "0%";
}

function newWord() {
    let originalWords = Object.keys(database);
    currentWord = originalWords[Math.floor(Math.random() * originalWords.length)];

    document.getElementById("displayContainer").innerHTML = currentWord
        .split("")
        .map((char) => `<span>${char}</span>`)
        .join("");
    document.getElementById("translateContainer").innerHTML = database[currentWord];

    currentIndex = 0;
    totalLength += currentWord.length;

    var progress = (totalWords / maxWords) * 100;
    document.getElementById("progressBar").style.width = progress + "%";
}

function newWordRandom() {
    let characters = "abcdefghijklmnopqrstuvwxyz01234567890123456789";
    let randomWord = "";
    let min = 5;
    let max = 10;
    let randomNum = Math.floor(Math.random() * (max - min + 1)) + min;
    for (let i = 0; i < randomNum; i++) {
        randomWord += characters[Math.floor(Math.random() * characters.length)];
    }

    currentWord = randomWord;

    document.getElementById("displayContainer").innerHTML = currentWord
        .split("")
        .map((char) => `<span>${char}</span>`)
        .join("");
    document.getElementById("translateContainer").innerHTML = "&nbsp;";

    currentIndex = 0;
    totalLength += currentWord.length;
    var progress = (totalWords / maxWords) * 100;
    document.getElementById("progressBar").style.width = progress + "%";
}

window.addEventListener("keydown", function (e) {
    if (e.key === " ") {
        e.preventDefault();
    }
});

window.addEventListener("keydown", (event) => {
    if (!startTime) {
        startTime = Date.now();
        timerInterval = setInterval(function () {
            let timeElapsed = Date.now() - startTime;
            document.getElementById("timer").innerText = (timeElapsed / 1000).toFixed(1).toString();
        }, 100);
    }

    if (event.key === currentWord[currentIndex]) {
        document.getElementById("displayContainer").children[currentIndex].classList.add("correct");
        currentIndex++;
        if (currentWord.length == currentIndex) {
            totalWords += 1;
            if (totalWords != maxWords) {
                if (typeSelect == "Word") {
                    newWord();
                } else if (typeSelect == "Random") {
                    newWordRandom();
                }
            }
        }
    } else {
        errors++;
        let incorrectElement = document.getElementById("displayContainer").children[currentIndex];
        if (incorrectElement) {
            incorrectElement.classList.add("incorrect");

            setTimeout(() => {
                incorrectElement.classList.remove("incorrect");
            }, 1000);
        }
    }

    if (totalWords === maxWords) {
        let endTime = Date.now();
        let timeTaken = ((endTime - startTime) / 1000).toFixed(0);
        let avgTimePerKey = (totalLength / ((endTime - startTime) / 1000)).toFixed(1);
        let rate = (((totalLength - errors) / totalLength) * 100).toFixed(1);
        let score = ((1 - errors / totalLength) * 3 * avgTimePerKey * maxWords).toFixed(0);
        window.location.href = `result.html?score=${score}&timeTaken=${timeTaken}&errors=${errors}&avgTimePerKey=${avgTimePerKey}&words=${maxWords}&type=${typeSelect}&rate=${rate}`;
    }
});
