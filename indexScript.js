let database = {
    declare: "宣言する",
    binary: "バイナリ",
    comment: "コメント",
    program: "プログラム",
    browser: "ブラウザ",
    execute: "実行",
    keyword: "キーワード",
    recursion: "再帰",
    variable: "変数",
    compiler: "コンパイラ",
    function: "関数",
    iteration: "反復",
    language: "言語",
    algorithm: "アルゴリズム",
    frontend: "フロントエンド",
    backend: "バックエンド",
    framework: "フレームワーク",
    database: "データベース",
    register: "登録",
    debugger: "デバッガ",
    document: "ドキュメント",
    hardware: "ハードウェア",
    software: "ソフトウェア",
    optimize: "最適化",
    template: "テンプレート",
    argument: "引数",
    modifier: "修飾子",
    instance: "インスタンス",
    abstract: "抽象的",
    exception: "例外",
    platform: "プラットフォーム",
    sentence: "文",
    internet: "インターネット",
    security: "セキュリティ",
    protocol: "プロトコル",
    operator: "演算子",
    reference: "参照",
    sequence: "順序",
    syntax: "構文",
    polyglot: "複数言語",
    responsive: "反応が良い",
    redundant: "冗長",
    deprecated: "非推奨",
    integrate: "統合",
    interface: "インターフェース",
    signature: "署名",
    migration: "移行",
    repository: "リポジトリ",
    principal: "主要な",
    directory: "ディレクトリ",
    narrative: "物語",
    proficient: "熟練した",
    reading: "読解",
    listening: "リスニング",
    grammar: "文法",
    vocabulary: "語彙",
    question: "問題",
    dialogue: "対話",
    passage: "文章",
    solution: "解決策",
    strategy: "戦略",
    practice: "練習",
    strength: "強さ",
    weakness: "弱点",
    progress: "進歩",
    overview: "概要",
    category: "カテゴリ",
    example: "例",
    session: "セッション",
    response: "レスポンス",
    correct: "正しい",
    incorrect: "間違い",
    explain: "説明する",
    feedback: "フィードバック",
    schedule: "スケジュール",
    deadline: "締切",
    duration: "期間",
    priority: "優先度",
    resource: "リソース",
    delivery: "納品",
    meeting: "会議",
    planning: "計画",
    status: "ステータス",
    progress: "進行状況",
    complete: "完了",
    estimate: "見積もり",
    objective: "目的",
    scope: "範囲",
    solution: "解決策",
    strategy: "戦略",
    timeline: "タイムライン",
    evaluate: "評価する",
    analyzer: "分析装置",
    discover: "発見する",
    emphasize: "強調する",
    feasible: "実現可能",
    guideline: "ガイドライン",
    implement: "実装する",
    increment: "増加する",
    influence: "影響",
    iteration: "繰り返し",
    milestone: "道しるべ",
    optimize: "最適化",
    overcome: "克服する",
    principle: "原則",
    prototype: "プロトタイプ",
    recursive: "再帰的",
    reliable: "信頼性",
    requisite: "必要条件",
    robustness: "堅牢性",
    technique: "技術",
    threshold: "しきい値",
    tolerance: "許容範囲",
    traceable: "トレーサビリティ",
    validation: "検証",
    versatile: "多目的",
    workflow: "ワークフロー",
    ambiguous: "曖昧な",
    efficient: "効率的",
    explicit: "明示的",
    invariant: "不変の",
    mutable: "可変の",
    premise: "前提",
    rationale: "根拠",
    standard: "標準",
    adherence: "遵守",
    compliant: "準拠",
    cohesive: "結束力",
    congruent: "一致する",
    implicit: "暗黙の",
    parallel: "並列",
    synthetic: "統合的",
    allegory: "寓話",
    exemplify: "例示する",
    analogy: "類似",
    articulate: "明確に述べる",
    explicit: "明確な",
    hypothesis: "仮説",
    metaphor: "隠喩",
    paradox: "逆説",
    rhetoric: "修辞",
    semantics: "意味論",
    syntax: "構文",
    vernacular: "日常言語",
    inference: "推論",
    presuppose: "前提とする",
    syllogism: "三段論法",
    tautology: "同義反復",
    theorem: "定理",
    premise: "前提",
    corollary: "系",
    exposition: "展示",
    intrinsic: "本質的",
    reciprocal: "相互の",
    transitive: "推移的",
    extrinsic: "外的",
    incidental: "付随的",
    orthogonal: "直交",
    surrogate: "代理",
    synthetic: "合成の",
    transient: "一時的",
    volatile: "揮発性",
    plethora: "過多",
    decipher: "解読する",
    elucidate: "明らかにする",
    explicate: "詳細に説明する",
    reiterate: "繰り返す",
    assimilate: "吸収する",
    cognizant: "認識して",
    comprehend: "理解する",
    intrinsic: "本質的",
    profound: "深い",
    tacit: "暗黙の",
    implicit: "暗黙の",
    aggregate: "集計する",
    allocate: "割り当てる",
    anomaly: "異常",
    artifact: "成果物",
    benchmark: "ベンチマーク",
    callback: "コールバック",
    checksum: "検査合計",
    concurrent: "同時に",
    dashboard: "ダッシュボード",
    deadlock: "行き詰まり",
    delimiter: "デリミタ",
    dependency: "依存関係",
    exception: "例外",
    factorial: "階乗",
    failover: "フェイルオーバ",
    flagship: "主力",
    handshake: "ハンドシェイク",
    heuristic: "発見的",
    identifier: "識別子",
    immutable: "不変の",
    incremental: "増分の",
    initializer: "初期化子",
    instantiate: "インスタンス化",
    interpreter: "通訳",
    intrusion: "侵入",
    juxtapose: "並置する",
    keystroke: "キーストローク",
    latency: "遅延",
    metadata: "メタデータ",
    middleware: "ミドルウェア",
    namespace: "ネームスペース",
    parameter: "パラメータ",
    query: "クエリ",
    recursion: "再帰",
    refactoring: "プログラム整理",
    regexp: "正規表現",
    repository: "リポジトリ",
    singleton: "1つだけ",
    standalone: "自立型",
    transaction: "トランザクション",
    unicode: "ユニコード",
    wildcard: "ワイルドカード",
    wrapper: "ラッパー",
    anecdote: "逸話",
    connotation: "含意",
    denotation: "表示、指示",
    dialect: "方言",
    hyperbole: "誇張表現",
    idiom: "熟語",
    irony: "皮肉",
    jargon: "専門用語",
    linguistics: "言語学",
    metonymy: "換喩",
    nuance: "ニュアンス",
    oxymoron: "矛盾語法",
    paraphrase: "言い換える",
    plagiarism: "盗用",
    proverb: "ことわざ",
    rhetorical: "修辞的",
    satire: "風刺",
    synonym: "同義語",
    vernacular: "方言",
    acronym: "頭字語",
    adjective: "形容詞",
    adverb: "副詞",
    affix: "接辞",
    anagram: "アナグラム",
    antonym: "反意語",
    apostrophe: "アポストロフィー",
    auxiliary: "助詞",
    diphthong: "二重母音",
    ellipsis: "省略",
    homonym: "同音異義語",
    hyphen: "ハイフン",
    infinitive: "不定詞",
    narrative: "物語",
    palindrome: "回文",
    plural: "複数形",
    possessive: "所有格",
    pronoun: "代名詞",
    rhyme: "韻を踏む",
    singular: "単数形",
    syllable: "音節",
    tense: "時制",
    underline: "下線",
    vowel: "母音",
    concrete: "具体的な",
    elaborate: "詳しく説明する",
    exemplify: "例証する",
    explicit: "明確な",
    implicit: "暗黙の",
    inherent: "固有の",
    innate: "生得的な",
    obscure: "曖昧な",
    omniscient: "全知の",
    perceptual: "知覚的な",
    presuppose: "前提とする",
    profound: "深淵な",
    tangible: "具体的な",
    transient: "一時的な",
    underscore: "強調する",
    permission: "許可する",
    parse: "解析する",
    fetch: "取ってくる",
    credential: "証明書",
    bundle: "束",
    conversion: "転換",
    replicate: "複製",
    revert: "元に戻す",
    terminate: "終了する",
    disable: "無効にする",
    contract: "契約",
    consumer: "消費者",
    dedicated: "専用の",
    persistent: "持続的に",
    decimals: "小数点",
    recipient: "受信者",
    proceed: "開始",
    verify: "確認",
    liquidity: "流動性",
    proof: "証拠",
    encryption: "暗号化",
    interaction: "相互作用",
    obsolete: "廃止",
    collapse: "崩壊",
    signature: "署名",
    procedure: "手順",
};

let currentWord = "";
let currentIndex = 0;
let startTime = 0.0;
let errors = 0;
let timerInterval;
let totalLength = 0;
let totalWords = 0;
let maxWords = 0;
let typeSelect = 1;
let setLevel = 1;
let levels = {
    1: 10,
    2: 30,
    3: 50,
};
let Types = {
    1: "Word",
    2: "Random",
};


window.onload = function () {
    let urlParams = new URLSearchParams(window.location.search);
    for (let key in levels) {
        if (levels[key] == urlParams.get("words")) {
            setLevel = key;
        }
    }
    for (let key in Types) {
        if (Types[key] == urlParams.get("type")) {
            typeSelect = key;
        }
    }
    changeType(typeSelect);
    startGame(setLevel);
    document.querySelector('label[for="level1"]').textContent = levels[1];
    document.querySelector('label[for="level2"]').textContent = levels[2];
    document.querySelector('label[for="level3"]').textContent = levels[3];
};

function changeType(type) {
    typeSelect = Types[type];
    startGame();
}

function changeLevel(level) {
    setLevel = level;
    startGame();
}

function startGame() {
    totalLength = 0;
    document.querySelectorAll('input[type="radio"]').forEach((elem) => {
        elem.checked = false;
    });

    document.querySelectorAll('input[type="radio"] + label').forEach((elem) => {
        elem.style.color = "#959595";
    });
    document.getElementById(`level${setLevel}`).checked = true;
    document.querySelector(`#level${setLevel} + label`).style.color = "orange";
    document.getElementById(typeSelect).checked = true;
    document.querySelector(`#${typeSelect} + label`).style.color = "orange";

    currentIndex = 0;
    errors = 0;
    clearInterval(timerInterval);
    startTime = 0.0;
    maxWords = levels[setLevel];
    if (typeSelect == "Word") {
        newWord();
    } else if (typeSelect == "Random") {
        newWordRandom();
    }
    document.getElementById("timer").innerText = "0.0";
    document.getElementById("progressBar").style.width = "0%";
}

function newWord() {
    let originalWords = Object.keys(database);
    currentWord = originalWords[Math.floor(Math.random() * originalWords.length)];

    document.getElementById("displayContainer").innerHTML = currentWord
        .split("")
        .map((char) => `<span>${char}</span>`)
        .join("");
    document.getElementById("translateContainer").innerHTML = database[currentWord];

    currentIndex = 0;
    totalLength += currentWord.length;

    var progress = (totalWords / maxWords) * 100;
    document.getElementById("progressBar").style.width = progress + "%";

    if(totalWords == 0){
        showBest("Word");
    }
}

function newWordRandom() {
    let characters = "abcdefghijklmnopqrstuvwxyz01234567890123456789";
    let randomWord = "";
    let min = 5;
    let max = 10;
    let randomNum = Math.floor(Math.random() * (max - min + 1)) + min;
    for (let i = 0; i < randomNum; i++) {
        randomWord += characters[Math.floor(Math.random() * characters.length)];
    }

    currentWord = randomWord;

    document.getElementById("displayContainer").innerHTML = currentWord
        .split("")
        .map((char) => `<span>${char}</span>`)
        .join("");
    document.getElementById("translateContainer").innerHTML = "&nbsp;";

    currentIndex = 0;
    totalLength += currentWord.length;
    var progress = (totalWords / maxWords) * 100;
    document.getElementById("progressBar").style.width = progress + "%";

    if(totalWords == 0){
        showBest("Random");
    }
}

function showBest(_type) {
    words = maxWords;
    type = _type;
    let localStorageKey = `${type}_${words}_bestScore`;
    let bestScore = localStorage.getItem(localStorageKey);
    document.getElementById("showBestScore").innerText = bestScore;
    if(bestScore == null){ document.getElementById("showBestScore").innerText = "---";}
}

function reload(){
    window.location.href = "index.html?words=" + levels[setLevel] + "&type=" + typeSelect;
}

function resetIndex(){
    totalWords = 0;
}

window.addEventListener("keydown", function (e) {
    if (e.key === " ") {
        e.preventDefault();
    }
});

window.addEventListener("keydown", (event) => {
    if (!startTime) {
        startTime = Date.now();
        timerInterval = setInterval(function () {
            let timeElapsed = Date.now() - startTime;
            document.getElementById("timer").innerText = (timeElapsed / 1000).toFixed(1).toString();
        }, 100);
    }

    if (event.key === currentWord[currentIndex]) {
        document.getElementById("displayContainer").children[currentIndex].classList.add("correct");
        currentIndex++;
        if (currentWord.length == currentIndex) {
            totalWords += 1;
            if (totalWords != maxWords) {
                if (typeSelect == "Word") {
                    newWord();
                } else if (typeSelect == "Random") {
                    newWordRandom();
                }

                if(totalWords==1){
                    AllHideBlock.classList.add('hideAll');
                }
            }
        }
    } else {
        errors++;
        let incorrectElement = document.getElementById("displayContainer").children[currentIndex];
        if (incorrectElement) {
            incorrectElement.classList.add("incorrect");

            setTimeout(() => {
                incorrectElement.classList.remove("incorrect");
            }, 200);
        }
    }

if (totalWords === maxWords) {
    let endTime = Date.now();
    let timeTaken = ((endTime - startTime) / 1000).toFixed(0);
    let avgTimePerKey = (totalLength / ((endTime - startTime) / 1000)).toFixed(1);
    let rate = (((totalLength - errors) / totalLength) * 100).toFixed(1);
        let score = ((1 - errors / totalLength) * 10 * (totalLength / ((endTime - startTime) / 1000)) * maxWords).toFixed(0);
        window.location.href = `result.html?score=${score}&timeTaken=${timeTaken}&errors=${errors}&avgTimePerKey=${avgTimePerKey}&words=${maxWords}&type=${typeSelect}&rate=${rate}`;
    }
});

document.getElementById("playReset").addEventListener("click", function () {
    reload();
});

document.querySelector('#hideBlock').addEventListener('click', function() {
    this.classList.add('moveUp');
    scoreLogo.classList.add('moveIn');
    showBestScore.classList.add('moveIn');
});

